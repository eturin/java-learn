
==================================================
Файл: ./HELP.md
==================================================

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/4.0.1/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/4.0.1/maven-plugin/build-image.html)
* [Spring Web](https://docs.spring.io/spring-boot/4.0.1/reference/web/servlet.html)
* [Flyway Migration](https://docs.spring.io/spring-boot/4.0.1/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)

### Guides
The following guides illustrate how to use some features concretely:

* [Building a RESTful Web Service](https://spring.io/guides/gs/rest-service/)
* [Serving Web Content with Spring MVC](https://spring.io/guides/gs/serving-web-content/)
* [Building REST services with Spring](https://spring.io/guides/tutorials/rest/)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.




==================================================
Файл: ./pom.xml
==================================================

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>4.0.1</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>ture</groupId>
    <artifactId>bank</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>bank</name>
    <description>Demo project for Spring Boot</description>
    <url/>
    <licenses>
        <license/>
    </licenses>
    <developers>
        <developer/>
    </developers>
    <scm>
        <connection/>
        <developerConnection/>
        <tag/>
        <url/>
    </scm>
    <properties>
        <java.version>17</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-flyway</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webmvc</artifactId>
        </dependency>
        <!-- Логирование (уже включено в spring-boot-starter-web) -->
        <!-- Для расширенной конфигурации логирования -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>

        <!-- Для JSON-формата логов -->
        <dependency>
            <groupId>net.logstash.logback</groupId>
            <artifactId>logstash-logback-encoder</artifactId>
            <version>7.4</version>
        </dependency>
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-database-postgresql</artifactId>
        </dependency>

        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-flyway-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webmvc-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.mindrot</groupId>
            <artifactId>jbcrypt</artifactId>
            <version>0.4</version>
        </dependency>

        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
                <version>3.6.0</version>
                <configuration>
                    <encoding>UTF-8</encoding>
                </configuration>
            </plugin>

        </plugins>
    </build>

    <reporting>
        <plugins>
            <!-- Генерация Javadoc сайта -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
                <version>3.6.0</version>
                <configuration>
                    <reportOutputDirectory>${project.build.directory}/site</reportOutputDirectory>
                    <destDir>apidocs</destDir>
                </configuration>
            </plugin>
        </plugins>
    </reporting>

</project>



==================================================
Файл: ./src/test/java/ture/bank/BankApplicationTests.java
==================================================

package ture.bank;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class BankApplicationTests {

	@Test
	void contextLoads() {
	}

}



==================================================
Файл: ./src/test/java/ture/bank/repository/UserRepositoryTest.java
==================================================

package ture.bank.repository;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import jakarta.persistence.EntityManager;
import static org.assertj.core.api.Assertions.assertThat;

import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;
import ture.bank.dto.RoleFilter;
import ture.bank.dto.StringFilter;
import ture.bank.dto.UserSearchCriteria;
import ture.bank.entity.Role;
import ture.bank.entity.User;
import ture.bank.repository.specification.UserSpecifications;
import ture.bank.util.PasswordHasher;

import java.util.List;
import java.util.Optional;

@SpringBootTest          // Загружает полный Spring контекст
@ActiveProfiles("test")  // Использует test профиль
@Transactional           // Выполнять в транзакции
public class UserRepositoryTest {
    @Autowired
    private EntityManager entityManager;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RoleRepository roleRepository;

    private String login = "test";
    private String pwd = "test123";
    private String fio = "test";
    private String roleName = "USER";

    @Test
    void newUser() {
        var user = new User();

        var pwdHash = PasswordHasher.hashPassword(pwd);

        Optional<Role> foundRole = roleRepository.findByName(roleName);
        assertThat(foundRole).isPresent();
        var role = foundRole.get();

        user = new User(login, fio, role, pwdHash);
        assertThat(user.getLogin()).isEqualTo(login);
        assertThat(user.getFio()).isEqualTo(fio);
        assertThat(user.getRole()).isEqualTo(role);
        assertThat(user.getPasswordHash()).isEqualTo(pwdHash);

        user = userRepository.save(user);
        assertThat(user.getId()).isNotZero();
        assertThat(user.getLogin()).isEqualTo(login);
        assertThat(user.getFio()).isEqualTo(fio);
        assertThat(user.getRole()).isEqualTo(role);
        assertThat(user.getPasswordHash()).isEqualTo(pwdHash);
    }

    @Test
    void updateUser() {
        var pwdHash = PasswordHasher.hashPassword(pwd);

        Optional<Role> foundRole = roleRepository.findByName(roleName);
        assertThat(foundRole).isPresent();
        var role = foundRole.get();

        var user = new User(login, fio, role, pwdHash);
        assertThat(user.getUpdatedAt()).isNull();
        user = userRepository.save(user);

        // Фиксируем изменения в БД
        entityManager.flush();
        // удаление из кэш JPA
        //entityManager.detach(user);


        //var foundUser = userRepository.findByLogin(login);
        //assertThat(foundUser).isPresent();
        //user = foundUser.get();
        assertThat(user.getFio()).isEqualTo(fio);
        assertThat(user.getUpdatedAt()).isNull();
        pwdHash = user.getPasswordHash();
        assertThat(PasswordHasher.checkPassword(pwd, pwdHash)).isTrue();
        user.setFio("test-test");
        user = userRepository.save(user);

        // сбрасываем в базу накопленные команды
        entityManager.flush();
        // перечитываем объект из базы
        entityManager.refresh(user);

        assertThat(user.getFio()).isEqualTo("test-test");
        assertThat(user.getUpdatedAt()).isNotNull();


        foundRole = roleRepository.findByName("ADMIN");
        assertThat(foundRole).isPresent();
        role = foundRole.get();
        user.setRole(role);
        userRepository.save(user);

        // сбрасываем в базу накопленные команды
        entityManager.flush();

        var foundUser = userRepository.findByLogin(login);
        assertThat(foundUser).isPresent();
        user = foundUser.get();
        assertThat(user.getRole()).isEqualTo(role);
    }

    @Test
    void pageUser() {
        Optional<Role> foundRole = roleRepository.findByName(roleName);
        assertThat(foundRole).isPresent();
        var role = foundRole.get();

        var total = 100;
        var pageSize = 10;

        for (var i = 0; i < total; i++) {
            var pwdHash = PasswordHasher.hashPassword(pwd + i);

            var user = new User(login + i, fio + i, role, pwdHash);
            userRepository.save(user);
        }

        Sort sort = Sort.by(Sort.Direction.fromString("DESC"), "login");
        for (var page = 0; page < total / pageSize; page++) {
            Pageable pageable = PageRequest.of(page, pageSize, sort);
            Page<User> userPage = userRepository.findAll(pageable);
            assertThat(userPage.getContent().size()).isLessThanOrEqualTo(pageSize);

            // Проверка сортировки
            List<User> users = userPage.getContent();
            if (users.size() > 1) {
                for (int i = 0; i < users.size() - 1; i++) {
                    // DESC сортировка по login
                    assertThat(users.get(i).getLogin()).isGreaterThan(users.get(i + 1).getLogin());
                }
            }
        }

        // критерий поиска
        var loginFilter = new StringFilter();
        loginFilter.setValue(login + 2);
        loginFilter.setOperator(StringFilter.Operator.CONTAINS);

        var roleFilter = new RoleFilter();
        roleFilter.setName("USER");
        roleFilter.setOperator(RoleFilter.Operator.EQUALS);

        var criteria = new UserSearchCriteria();
        criteria.setLogin(List.of(loginFilter));
        criteria.setRole(List.of(roleFilter));

        Specification<User> spec = UserSpecifications.withCriteria(criteria);
        Pageable pageable = PageRequest.of(0, 10, Sort.by("login").ascending());

        // When
        Page<User> page = userRepository.findAll(spec, pageable);

        // Then
        assertThat(page.getContent()).hasSize(10);
        assertThat(page.getContent())
                .extracting(User::getLogin)
                .containsExactly(login + 2,
                                         login + 20,
                                         login + 21,
                                         login + 22,
                                         login + 23,
                                         login + 24,
                                         login + 25,
                                         login + 26,
                                         login + 27,
                                         login + 28);
    }
}



==================================================
Файл: ./src/test/java/ture/bank/repository/RoleRepositoryTest.java
==================================================

package ture.bank.repository;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import static org.assertj.core.api.Assertions.assertThat;

import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.transaction.annotation.Transactional;
import ture.bank.entity.Role;
import java.util.Optional;

@SpringBootTest          // Загружает полный Spring контекст
@ActiveProfiles("test")  // Использует test профиль
@Transactional           // Откатывает транзакции после тестов
public class RoleRepositoryTest {
    @Autowired
    private RoleRepository roleRepository;

    @Test
    void shouldBe() {
        Role role = new Role();
    }

    @Test
    void shouldFindRoleByName() {

        Object[][] m = {
                {"USER", "Пользователь"},
                {"ADMIN", "Администратор"}
        };
        for(Object[] x : m) {
            var roleName = (String) x[0];
            var description = (String) x[1];

            Optional<Role> foundRole = roleRepository.findByName(roleName);

            assertThat(foundRole).isPresent();
            assertThat(foundRole.get().getName()).isEqualTo(roleName);
            assertThat(foundRole.get().getDescription()).isEqualTo(description);
        }
    }
}



==================================================
Файл: ./src/main/java/ture/bank/BankApplication.java
==================================================

package ture.bank;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Основной класс Spring Boot приложения "Bank".
 * <p>
 * Этот класс запускает Spring Boot приложение и инициализирует все компоненты.
 * Приложение предоставляет REST API для управления операциями между картами,
 * пользователями и ролями с использованием PostgreSQL и Flyway для миграций.
 * </p>
 *
 */
@SpringBootApplication
public class BankApplication {

	public static void main(String[] args) {
		SpringApplication.run(BankApplication.class, args);
	}

}



==================================================
Файл: ./src/main/java/ture/bank/dto/DateFilter.java
==================================================

package ture.bank.dto;

import java.time.Instant;

/**
 * Фильтр для дат
 */
public class DateFilter {
    private Instant from;
    private Instant to;
    private Operator operator;

    public enum Operator {
        EQUALS, NOT_EQUALS, GREATER_THAN, LESS_THAN, BETWEEN
    }

    // Getters and Setters
    public Instant getFrom() {
        return from;
    }

    public void setFrom(Instant from) {
        this.from = from;
    }

    public Instant getTo() {
        return to;
    }

    public void setTo(Instant to) {
        this.to = to;
    }

    public Operator getOperator() {
        return operator != null ? operator : Operator.EQUALS;
    }

    public void setOperator(Operator operator) {
        this.operator = operator;
    }
}




==================================================
Файл: ./src/main/java/ture/bank/dto/RoleFilter.java
==================================================

package ture.bank.dto;

/**
 * Фильтр для ролей
 */
public class RoleFilter {
    private Long id;
    private String name;
    private StringFilter nameFilter;
    private Operator operator;
    private LogicalOperator logicalOperator;

    public enum Operator {
        EQUALS, NOT_EQUALS, IN, NOT_IN
    }

    public enum LogicalOperator {
        AND, OR
    }

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public StringFilter getNameFilter() {
        return nameFilter;
    }

    public void setNameFilter(StringFilter nameFilter) {
        this.nameFilter = nameFilter;
    }

    public Operator getOperator() {
        return operator != null ? operator : Operator.EQUALS;
    }

    public void setOperator(Operator operator) {
        this.operator = operator;
    }

    public LogicalOperator getLogicalOperator() {
        return logicalOperator != null ? logicalOperator : LogicalOperator.AND;
    }

    public void setLogicalOperator(LogicalOperator logicalOperator) {
        this.logicalOperator = logicalOperator;
    }
}



==================================================
Файл: ./src/main/java/ture/bank/dto/UserSearchCriteria.java
==================================================

package ture.bank.dto;

import java.util.List;

/**
 * DTO для гибкой фильтрации пользователей
 */
public class UserSearchCriteria {
    private List<StringFilter> login;
    private List<StringFilter> fio;
    private List<RoleFilter> role;
    private DateFilter createdAt;
    private DateFilter updatedAt;
    private Boolean deleted;
    private Integer page;
    private Integer size;
    private String sortBy;
    private String sortDirection;

    public UserSearchCriteria() {}

    // Getters and Setters
    public List<StringFilter> getLogin() {
        return login;
    }

    public void setLogin(List<StringFilter> login) {
        this.login = login;
    }

    public List<StringFilter> getFio() {
        return fio;
    }

    public void setFio(List<StringFilter> fio) {
        this.fio = fio;
    }

    public List<RoleFilter> getRole() {
        return role;
    }

    public void setRole(List<RoleFilter> role) {
        this.role = role;
    }

    public DateFilter getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(DateFilter createdAt) {
        this.createdAt = createdAt;
    }

    public DateFilter getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(DateFilter updatedAt) {
        this.updatedAt = updatedAt;
    }

    public Boolean getDeleted() {
        return deleted;
    }

    public void setDeleted(Boolean deleted) {
        this.deleted = deleted;
    }

    public Integer getPage() {
        return page != null ? page : 0;
    }

    public void setPage(Integer page) {
        this.page = page;
    }

    public Integer getSize() {
        return size != null ? size : 10;
    }

    public void setSize(Integer size) {
        this.size = size;
    }

    public String getSortBy() {
        return sortBy != null ? sortBy : "id";
    }

    public void setSortBy(String sortBy) {
        this.sortBy = sortBy;
    }

    public String getSortDirection() {
        return sortDirection != null ? sortDirection : "asc";
    }

    public void setSortDirection(String sortDirection) {
        this.sortDirection = sortDirection;
    }
}








==================================================
Файл: ./src/main/java/ture/bank/dto/StringFilter.java
==================================================

package ture.bank.dto;

/**
 * Фильтр для строковых полей
 */
public class StringFilter {
    private String value;
    private Operator operator;
    private LogicalOperator logicalOperator; // AND или OR для связи с другими фильтрами того же поля

    public enum Operator {
        EQUALS,           // точное совпадение
        NOT_EQUALS,       // не равно
        CONTAINS,         // содержит подстроку
        STARTS_WITH,      // начинается с
        ENDS_WITH,        // заканчивается на
        IN,               // в списке значений (через запятую)
        NOT_IN            // не в списке значений
    }

    public enum LogicalOperator {
        AND, OR
    }

    public StringFilter() {}

    public StringFilter(String value, Operator operator) {
        this.value = value;
        this.operator = operator;
        this.logicalOperator = LogicalOperator.AND;
    }

    // Getters and Setters
    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }

    public Operator getOperator() {
        return operator != null ? operator : Operator.EQUALS;
    }

    public void setOperator(Operator operator) {
        this.operator = operator;
    }

    public LogicalOperator getLogicalOperator() {
        return logicalOperator != null ? logicalOperator : LogicalOperator.AND;
    }

    public void setLogicalOperator(LogicalOperator logicalOperator) {
        this.logicalOperator = logicalOperator;
    }
}


==================================================
Файл: ./src/main/java/ture/bank/util/PasswordHasher.java
==================================================

package ture.bank.util;

import org.mindrot.jbcrypt.BCrypt;

/**
 * Вспоиогательный класс для работы с паролями
 */
public class PasswordHasher {

    /**
     * Генерация хеша пароля
     * @param plainPassword исходный пароль
     * @return хеш пароля для хранения в БД
     */
    public static String hashPassword(String plainPassword) {
        // Генерируем соль и хеш автоматически
        return BCrypt.hashpw(plainPassword, BCrypt.gensalt());
    }

    /**
     * Проверка пароля
     * @param plainPassword пароль для проверки
     * @param hashedPassword хеш из БД
     * @return true если пароль верный
     */
    public static boolean checkPassword(String plainPassword, String hashedPassword) {
        return BCrypt.checkpw(plainPassword, hashedPassword);
    }
}


==================================================
Файл: ./src/main/java/ture/bank/entity/Role.java
==================================================

package ture.bank.entity;

import jakarta.persistence.*;

/**
 * Сущность, представляющая роль в системе.
 * <p>
 * Java-класс, который представляет таблицу {@code roles} в базе данных.
 * Этот класс будет "отражением" таблицы в базе данных. Какое поле в классе - такой столбец в таблице..
 * </p>
 */
@Entity
@Table(name = "roles")
public class Role {
    /**
     * Идентификатор роли
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Наименование роли
     */
    @Column(name = "name", nullable = false)
    private String name;

    /**
     * Описание роли
     */
    @Column(name = "description", nullable = false)
    private String description;

    /**
     * Конструктор без параметров - требование спецификации JPA
     */
    public Role() {}

    /**
     * Получение идентификатора роли
     * @return Long
     */
    public Long getId() {
        return id;
    }

    /**
     * Получение наименования роли
     * @return String
     */
    public String getName() {
        return name;
    }

    /**
     * Получение описания роли
     * @return String
     */
    public String getDescription() {
        return description;
    }
}



==================================================
Файл: ./src/main/java/ture/bank/entity/User.java
==================================================

package ture.bank.entity;
import jakarta.persistence.*;
import java.time.Instant;

/**
 * Сущность, представляющая пользователя в системе.
 * <p>
 * Java-класс, который представляет таблицу {@code users} в базе данных.
 * Этот класс будет "отражением" таблицы в базе данных. Какое поле в классе - такой столбец в таблице..
 * </p>
 */
@Entity
@Table(name = "users")
public class User {
    /**
     * Идентификатор роли
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Логин пользователя (уникальный)
     */
    @Column(name = "login", nullable = false, unique = true, length = 50)
    private String login;

    /**
     * ФИО пользователя
     */
    @Column(name = "fio", length = 255)
    private String fio;

    /**
     * Роль пользователя
     * @see Role
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "role_id", nullable = false, foreignKey = @ForeignKey(name = "fk_users_role_id"))
    private Role role;

    /**
     * Хеш пароля (BCrypt)
     */
    @Column(name = "pwd_hash", nullable = false, length = 255)
    private String passwordHash;

    /**
     * Дата и время создания пользователя
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    /**
     * Дата и время последнего обновления пользователя
     */
    @Column(name = "updated_at")
    private Instant updatedAt;

    /**
     * Дата и время удаления пользователя (мягкое удаление)
     */
    @Column(name = "deleted_at")
    private Instant deletedAt;

    /**
     * Конструктор без параметров - требование спецификации JPA
     */
    public User() {}

    /**
     * Приватная функция заполнения инкапсулирующая инициализацию экземпляра
     * @param login
     * @param fio
     * @param role
     * @param passwordHash
     */
    private void fill(String login, String fio, Role role, String passwordHash) {
        this.login = login;
        this.fio = fio;
        this.role = role;
        this.passwordHash = passwordHash;
    }

    /**
     * Конструктор с основными параметрами
     * @param login логин пользователя
     * @param role роль пользователя
     * @param passwordHash хеш пароля
     */
    public User(String login, Role role, String passwordHash) {
        fill(login, null, role, passwordHash);
    }

    /**
     * Конструктор с основными параметрами
     * @param login логин пользователя
     * @param fio ФИО пользователя
     * @param role роль пользователя
     * @param passwordHash хеш пароля
     */
    public User(String login, String fio, Role role, String passwordHash) {
        fill(login, fio, role, passwordHash);
    }

    /**
     * Callback метод, вызываемый перед сохранением новой записи
     */
    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = Instant.now(); // UTC время
        }
    }

    /**
     * Получение идентификатора пользователя
     * @return Long
     */
    public Long getId() {
        return id;
    }

    /**
     * Получение логина пользователя
     * @return String
     */
    public String getLogin() {
        return login;
    }

    /**
     * Получение ФИО пользователя
     * @return String
     */
    public String getFio() {
        return fio;
    }

    /**
     * Получение роли пользователя
     * @return Role
     */
    public Role getRole() {
        return role;
    }

    /**
     * Получение хеша пароля пользователя
     * @return String
     */
    public String getPasswordHash() {
        return passwordHash;
    }

    /**
     * Получение даты добавления пользователя
     * @return java.time.Instant
     */
    public Instant getCreatedAt() {
        return createdAt;
    }

    /**
     * Получение даты изменения свойств пользователя
     * @return java.time.Instant
     */
    public Instant getUpdatedAt() {
        return updatedAt;
    }

    /**
     * Получение даты удаления пользователя
     * @return java.time.Instant
     */
    public Instant getDeletedAt() {
        return deletedAt;
    }

    /**
     * Проверка, удален ли пользователь
     * @return true если пользователь удален
     */
    public boolean isDeleted() {
        return deletedAt != null;
    }

    /**
     * Изменение ФИО пользователя
     * @param fio ФИО пользователя
     */
    public void setFio(String fio) {
        this.fio = fio;
    }

    /**
     * Изменение роли пользователя
     * @param role роль пользователя
     */
    public void setRole(Role role) {
        this.role = role;
    }
}



==================================================
Файл: ./src/main/java/ture/bank/repository/RoleRepository.java
==================================================

package ture.bank.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import ture.bank.entity.Role;

import java.util.Optional;

/**
 * Интерфейс RoleRepository будет отвечать за операции с базой данных.
 * Для чего это нужно:
 *  - Repository - это прослойка между приложением и базой данных
 *  - Spring Data JPA автоматически создает реализации методов
 *  - Мы получаем готовые методы для CRUD операций (Create, Read, Update, Delete)
 */
@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
    /**
     * Spring реализует автоматически этот метод
     * @param name имя роли для поиска (не должно быть {@code null})
     * @return {@link Optional} содержащий роль если найдена, иначе пустой {@link Optional}
     */
    Optional<Role> findByName(String name);
}



==================================================
Файл: ./src/main/java/ture/bank/repository/UserRepository.java
==================================================

package ture.bank.repository;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import ture.bank.entity.User;

import java.util.Optional;

/**
 * Интерфейс UserRepository будет отвечать за операции с базой данных.
 * Для чего это нужно:
 *  - Repository - это прослойка между приложением и базой данных
 *  - Spring Data JPA автоматически создает реализации методов
 *  - Мы получаем готовые методы для CRUD операций (Create, Read, Update, Delete)
 */
@Repository
public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
    // JPQL - в запросе сущности java приложения, а не таблицы СУБД
    @Query("SELECT u FROM User u WHERE u.login = :login")
    Optional<User> findByLogin(@Param("login") String login);

    /**
     * Поиск пользователей с пагинацией
     * (JPQL - самостоятельно реализует метод)
     * @param pageable объект пагинации
     * @return страница пользователей
     */
    Page<User> findAll(Pageable pageable);
}



==================================================
Файл: ./src/main/java/ture/bank/repository/specification/UserSpecifications.java
==================================================

package ture.bank.repository.specification;

import jakarta.persistence.criteria.*;
import org.springframework.data.jpa.domain.Specification;
import ture.bank.dto.*;
import ture.bank.entity.Role;
import ture.bank.entity.User;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class UserSpecifications {

    public static Specification<User> withCriteria(UserSearchCriteria criteria) {
        return (root, query, cb) -> {
            List<Predicate> predicates = new ArrayList<>();

            // Добавляем фильтры по логину
            if (criteria.getLogin() != null && !criteria.getLogin().isEmpty()) {
                Predicate loginPredicate = buildStringPredicates(
                        criteria.getLogin(),
                        root.get("login"),
                        cb
                );
                if (loginPredicate != null) {
                    predicates.add(loginPredicate);
                }
            }

            // Добавляем фильтры по ФИО
            if (criteria.getFio() != null && !criteria.getFio().isEmpty()) {
                Predicate fioPredicate = buildStringPredicates(
                        criteria.getFio(),
                        root.get("fio"),
                        cb
                );
                if (fioPredicate != null) {
                    predicates.add(fioPredicate);
                }
            }

            // Добавляем фильтры по роли
            if (criteria.getRole() != null && !criteria.getRole().isEmpty()) {
                Join<User, Role> roleJoin = root.join("role", JoinType.INNER);
                Predicate rolePredicate = buildRolePredicates(
                        criteria.getRole(),
                        roleJoin,
                        cb
                );
                if (rolePredicate != null) {
                    predicates.add(rolePredicate);
                }
            }

            // Добавляем фильтр по дате создания
            if (criteria.getCreatedAt() != null) {
                Predicate datePredicate = buildDatePredicate(
                        criteria.getCreatedAt(),
                        root.get("createdAt"),
                        cb
                );
                if (datePredicate != null) {
                    predicates.add(datePredicate);
                }
            }

            // Добавляем фильтр по дате обновления
            if (criteria.getUpdatedAt() != null) {
                Predicate datePredicate = buildDatePredicate(
                        criteria.getUpdatedAt(),
                        root.get("updatedAt"),
                        cb
                );
                if (datePredicate != null) {
                    predicates.add(datePredicate);
                }
            }

            // Добавляем фильтр по удаленным пользователям
            if (criteria.getDeleted() != null) {
                if (criteria.getDeleted()) {
                    predicates.add(cb.isNotNull(root.get("deletedAt")));
                } else {
                    predicates.add(cb.isNull(root.get("deletedAt")));
                }
            }

            return cb.and(predicates.toArray(new Predicate[0]));
        };
    }

    private static Predicate buildStringPredicates(
            List<StringFilter> filters,
            Path<String> path,
            CriteriaBuilder cb
    ) {
        List<Predicate> predicates = new ArrayList<>();

        for (int i = 0; i < filters.size(); i++) {
            StringFilter filter = filters.get(i);
            if (filter.getValue() == null || filter.getValue().trim().isEmpty()) {
                continue;
            }

            Predicate predicate = buildStringPredicate(filter, path, cb);
            if (predicate != null) {
                predicates.add(predicate);
            }
        }

        if (predicates.isEmpty()) {
            return null;
        }

        // Объединяем предикаты с учетом логических операторов
        Predicate result = predicates.get(0);
        for (int i = 1; i < predicates.size(); i++) {
            if (filters.get(i).getLogicalOperator() == StringFilter.LogicalOperator.OR) {
                result = cb.or(result, predicates.get(i));
            } else {
                result = cb.and(result, predicates.get(i));
            }
        }

        return result;
    }

    private static Predicate buildStringPredicate(
            StringFilter filter,
            Path<String> path,
            CriteriaBuilder cb
    ) {
        String value = filter.getValue().trim();

        switch (filter.getOperator()) {
            case EQUALS:
                return cb.equal(cb.lower(path), value.toLowerCase());

            case NOT_EQUALS:
                return cb.notEqual(cb.lower(path), value.toLowerCase());

            case CONTAINS:
                return cb.like(cb.lower(path), "%" + value.toLowerCase() + "%");

            case STARTS_WITH:
                return cb.like(cb.lower(path), value.toLowerCase() + "%");

            case ENDS_WITH:
                return cb.like(cb.lower(path), "%" + value.toLowerCase());

            case IN:
                List<String> values = Arrays.asList(value.split(","));
                return cb.lower(path).in(
                        values.stream()
                                .map(String::trim)
                                .map(String::toLowerCase)
                                .toArray()
                );

            case NOT_IN:
                List<String> notInValues = Arrays.asList(value.split(","));
                return cb.not(cb.lower(path).in(
                        notInValues.stream()
                                .map(String::trim)
                                .map(String::toLowerCase)
                                .toArray()
                ));

            default:
                return cb.equal(cb.lower(path), value.toLowerCase());
        }
    }

    private static Predicate buildRolePredicates(
            List<RoleFilter> filters,
            Join<User, Role> roleJoin,
            CriteriaBuilder cb
    ) {
        List<Predicate> predicates = new ArrayList<>();

        for (int i = 0; i < filters.size(); i++) {
            RoleFilter filter = filters.get(i);
            Predicate predicate = buildRolePredicate(filter, roleJoin, cb);
            if (predicate != null) {
                predicates.add(predicate);
            }
        }

        if (predicates.isEmpty()) {
            return null;
        }

        // Объединяем предикаты
        Predicate result = predicates.get(0);
        for (int i = 1; i < predicates.size(); i++) {
            if (filters.get(i).getLogicalOperator() == RoleFilter.LogicalOperator.OR) {
                result = cb.or(result, predicates.get(i));
            } else {
                result = cb.and(result, predicates.get(i));
            }
        }

        return result;
    }

    private static Predicate buildRolePredicate(
            RoleFilter filter,
            Join<User, Role> roleJoin,
            CriteriaBuilder cb
    ) {
        if (filter.getId() != null) {
            switch (filter.getOperator()) {
                case EQUALS:
                    return cb.equal(roleJoin.get("id"), filter.getId());
                case NOT_EQUALS:
                    return cb.notEqual(roleJoin.get("id"), filter.getId());
                default:
                    return cb.equal(roleJoin.get("id"), filter.getId());
            }
        } else if (filter.getName() != null) {
            switch (filter.getOperator()) {
                case EQUALS:
                    return cb.equal(cb.lower(roleJoin.get("name")), filter.getName().toLowerCase());
                case NOT_EQUALS:
                    return cb.notEqual(cb.lower(roleJoin.get("name")), filter.getName().toLowerCase());
                default:
                    return cb.equal(cb.lower(roleJoin.get("name")), filter.getName().toLowerCase());
            }
        } else if (filter.getNameFilter() != null) {
            return buildStringPredicate(filter.getNameFilter(), roleJoin.get("name"), cb);
        }

        return null;
    }

    private static Predicate buildDatePredicate(
            DateFilter filter,
            Path<Instant> path,
            CriteriaBuilder cb
    ) {
        switch (filter.getOperator()) {
            case EQUALS:
                return cb.equal(path, filter.getFrom());

            case NOT_EQUALS:
                return cb.notEqual(path, filter.getFrom());

            case GREATER_THAN:
                return cb.greaterThan(path, filter.getFrom());

            case LESS_THAN:
                return cb.lessThan(path, filter.getFrom());

            case BETWEEN:
                if (filter.getFrom() != null && filter.getTo() != null) {
                    return cb.between(path, filter.getFrom(), filter.getTo());
                } else if (filter.getFrom() != null) {
                    return cb.greaterThanOrEqualTo(path, filter.getFrom());
                } else if (filter.getTo() != null) {
                    return cb.lessThanOrEqualTo(path, filter.getTo());
                }
                return null;

            default:
                return cb.equal(path, filter.getFrom());
        }
    }
}



==================================================
Файл: ./src/main/resources/application.yaml
==================================================

spring:
  application:
    name: bank

  # JPA properties
  jpa:
    database-platform: "org.hibernate.dialect.PostgreSQLDialect"
    show-sql: true
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        format_sql: true

  # Database
  datasource:
    url: "jdbc:postgresql://localhost:5432/bank"
    username: "postgres"
    password: "postgres"

    # Optional: connection pool
    hikari:
      maximum-pool-size: 10
      minimum-idle: 2
  
  # Flyway properties
  flyway:
    enabled: true
    locations: classpath:db/migration


==================================================
Файл: ./src/main/resources/db/migration/V1__User_Roles.sql
==================================================

-- Таблица для хранения ролей пользователей
CREATE TABLE if not exists roles
(
    id          BIGSERIAL PRIMARY KEY,
    name        VARCHAR(50) NOT NULL UNIQUE,
    description VARCHAR(255)
);

COMMENT ON TABLE roles IS 'Роли пользователей';
COMMENT ON COLUMN roles.id IS 'Уникальный идентификатор';
COMMENT ON COLUMN roles.name IS 'Код роли (например: USER, ADMIN)';
COMMENT ON COLUMN roles.description IS 'Описание';

-- Добавляем базовые роли
INSERT INTO roles (name, description)
VALUES ('USER', 'Пользователь'),
       ('ADMIN', 'Администратор')
ON CONFLICT (name) DO UPDATE
    SET description = EXCLUDED.description;




==================================================
Файл: ./src/main/resources/db/migration/V2__Users.sql
==================================================

-- Таблица для хранения ролей пользователей
CREATE TABLE if not exists users
(
    id          BIGSERIAL PRIMARY KEY,
    login       VARCHAR(50) NOT NULL UNIQUE,
    fio         VARCHAR(255),
    role_id     BIGINT not null REFERENCES roles(id) ON DELETE RESTRICT,
    pwd_hash    VARCHAR(255) NOT NULL,         -- Хеш пароля (BCrypt)
    created_at  TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at  TIMESTAMP,
    deleted_at  TIMESTAMP
);

COMMENT ON TABLE users IS 'Пользователи';
COMMENT ON COLUMN users.id IS 'Уникальный идентификатор';
COMMENT ON COLUMN users.login IS 'Логин';
COMMENT ON COLUMN users.fio IS 'ФИО';
COMMENT ON COLUMN users.role_id IS 'Идентификато роли';
COMMENT ON COLUMN users.pwd_hash IS 'Хеш пароля';
COMMENT ON COLUMN users.created_at IS 'Дата добавления пользователя';
COMMENT ON COLUMN users.updated_at IS 'Дата изменения свойств пользователя';
COMMENT ON COLUMN users.deleted_at IS 'Дата удаления пользователя';

-- Добавляем функцию и триггер
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();


-- Добавляем администатора
-- Пароль: admin123
INSERT INTO users (login, role_id, pwd_hash)
VALUES ('admin', (select id from roles where name = 'ADMIN' limit 1), '$2a$10$N9qo8uLOickgx2ZMRZoMyeaj6vWj8.9.3Z1Q9P5Qw2Yz5h6G8vQO')
    ON CONFLICT (login) DO nothing;


